---
phase: 3-decision-rules-engine
plan: 04
type: execute
depends_on: ["3-01", "3-02", "3-03"]
files_modified: [src/v6/alerts/__init__.py, src/v6/alerts/models.py, src/v6/alerts/manager.py, src/v6/alerts/test_manager.py]
domain: quant-options
---

<objective>
Implement alert generation and management system for decision notifications.

Purpose: Track, persist, and manage alerts generated by decision rules (e.g., "Take Profit triggered on SPY IC"), enable alert history queries, and support alert notifications.

Output: AlertManager with persistence, alert models, Delta Lake storage, and unit tests.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-plan.md
~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/3-decision-rules-engine/3-01-SUMMARY.md (DecisionEngine)
@.planning/phases/3-decision-rules-engine/3-03-SUMMARY.md (Decision rules)
@src/v6/decisions/models.py (Decision models)
@src/v6/decisions/engine.py (DecisionEngine)
@src/v6/data/delta_persistence.py (Delta Lake patterns from Phase 2)
@~/.claude/skills/expertise/quant-options/SKILL.md (options domain knowledge)

**Alert types:**
- **Info**: Normal operations (DTE roll reminder, position opened)
- **Warning**: Risk warnings (delta approaching limit, gamma risk)
- **Critical**: Immediate action required (catastrophe protection, stop loss)

**Alert severity:**
- IMMEDIATE: Act now (catastrophe, stop loss)
- HIGH: Act soon (take profit approaching)
- NORMAL: Monitor (DTE roll coming up)
- LOW: Informational (position stats)

**Tech stack available:**
- Delta Lake for persistence (from Phase 2)
- dataclass(slots=True) for performance (from Phase 1)
- Async/await pattern (from Phase 2)

**Established patterns:**
- Delta Lake for all persistence (from Phase 2)
- dataclass(slots=True) (from Phase 1)
- Handler registration (from Phase 2)

**Key decisions from 3-01, 3-02, 3-03:**
- Protocol-based interfaces
- Async design
- Priority-based execution
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create alert models and enums</name>
  <files>src/v6/alerts/models.py</files>
  <action>
Create alert data models and enums:

1. **AlertType enum**: INFO, WARNING, CRITICAL
2. **AlertSeverity enum**: IMMEDIATE, HIGH, NORMAL, LOW
3. **AlertStatus enum**: ACTIVE, ACKNOWLEDGED, RESOLVED, DISMISSED
4. **Alert dataclass** (slots=True):
   - alert_id: str (UUID)
   - type: AlertType
   - severity: AlertSeverity
   - status: AlertStatus
   - title: str (short summary, e.g., "Take Profit triggered")
   - message: str (detailed description)
   - rule: str (which rule triggered)
   - symbol: str | None
   - strategy_id: int | None
   - metadata: dict[str, Any] (rule-specific data)
   - created_at: datetime
   - acknowledged_at: datetime | None
   - resolved_at: datetime | None

5. **AlertQuery dataclass** (slots=True):
   - symbol: str | None
   - strategy_id: int | None
   - status: AlertStatus | None
   - type: AlertType | None
   - severity: AlertSeverity | None
   - start_time: datetime | None
   - end_time: datetime | None
   - limit: int = 100

Use @dataclass(slots=True). Add validation in __post_init__. Use uuid.uuid4() for alert_id generation.
  </action>
  <verify>
python -c "
from src.v6.alerts.models import Alert, AlertType, AlertSeverity, AlertStatus
from datetime import datetime
alert = Alert(
    alert_id='test-123',
    type=AlertType.WARNING,
    severity=AlertSeverity.HIGH,
    status=AlertStatus.ACTIVE,
    title='Delta limit approaching',
    message='SPY portfolio delta at 0.28, limit is 0.30',
    rule='delta_risk',
    symbol='SPY',
    strategy_id=123,
    metadata={'delta': 0.28, 'limit': 0.30},
    created_at=datetime.now()
)
print(alert)
" executes without errors
  </verify>
  <done>
All enums and models created, validation works, type hints complete
  </done>
</task>

<task type="auto">
  <name>Task 2: Create AlertManager with Delta Lake persistence</name>
  <files>src/v6/alerts/manager.py, src/v6/alerts/__init__.py</files>
  <action>
Create AlertManager class with Delta Lake persistence:

**Class structure:**
```python
class AlertManager:
    def __init__(self, delta_lake_path: str = "data/lake/alerts")
    async def initialize(self) -> None
    async def create_alert(self, decision: Decision, snapshot: PositionSnapshot | None = None) -> Alert
    async def acknowledge_alert(self, alert_id: str) -> Alert
    async def resolve_alert(self, alert_id: str) -> Alert
    async def dismiss_alert(self, alert_id: str) -> Alert
    async def query_alerts(self, query: AlertQuery) -> list[Alert]
    async def get_active_alerts(self) -> list[Alert]
    async def get_alert_count(self, status: AlertStatus | None = None) -> int
```

**Implementation:**
1. **initialize()**: Create Delta Lake table if not exists (schema matching Alert model)
2. **create_alert()**:
   - Generate alert_id (uuid4)
   - Map Decision to Alert:
     - DecisionAction.CLOSE with urgency=IMMEDIATE → AlertType.CRITICAL, severity=IMMEDIATE
     - DecisionAction.CLOSE with urgency=HIGH → AlertType.WARNING, severity=HIGH
     - DecisionAction.ROLL → AlertType.INFO, severity=NORMAL
     - DecisionAction.HOLD → No alert (skip)
   - Extract metadata from decision.metadata
   - Write to Delta Lake (append)
   - Return created Alert
3. **acknowledge_alert()**: Update status=ACKNOWLEDGED, acknowledged_at=now(), write to Delta Lake
4. **resolve_alert()**: Update status=RESOLVED, resolved_at=now(), write to Delta Lake
5. **dismiss_alert()**: Update status=DISMISSED, resolved_at=now(), write to Delta Lake
6. **query_alerts()**: Read from Delta Lake, filter by query fields, use polars for efficiency
7. **get_active_alerts()**: Query alerts where status=ACTIVE
8. **get_alert_count()**: Count alerts by status (or all if None)

**Delta Lake schema:**
```
alerts/
  - alert_id: string
  - type: string
  - severity: string
  - status: string
  - title: string
  - message: string
  - rule: string
  - symbol: string
  - strategy_id: int
  - metadata: string (JSON)
  - created_at: timestamp
  - acknowledged_at: timestamp
  - resolved_at: timestamp
```

Use Delta Lake patterns from src/v6/data/delta_persistence.py (write_deltalake, read with polars). Serialize metadata dict to JSON string for storage.
  </action>
  <verify>
python -c "
from src.v6.alerts.manager import AlertManager
from src.v6.decisions.models import Decision, DecisionAction, Urgency
import asyncio
async def test():
    manager = AlertManager()
    await manager.initialize()
    count = await manager.get_alert_count()
    print(f'Alerts in store: {count}')
asyncio.run(test())
" executes and shows alert count (0 for new database)
  </verify>
  <done>
AlertManager created, Delta Lake persistence works, create_alert() maps Decision to Alert correctly, query works
  </done>
</task>

<task type="auto">
  <name>Task 3: Create DecisionEngine integration and unit tests</name>
  <files>src/v6/alerts/test_manager.py, src/v6/decisions/engine.py</files>
  <action>
Create unit tests and DecisionEngine integration:

**Unit tests (src/v6/alerts/test_manager.py):**
1. **test_create_alert_from_decision**: Create CLOSE decision → Alert created with CRITICAL type
2. **test_roll_decision_creates_info_alert**: Create ROLL decision → Alert created with INFO type
3. **test_hold_decision_skips_alert**: Create HOLD decision → No alert created (returns None)
4. **test_acknowledge_alert**: Create alert → acknowledge → status=ACKNOWLEDGED, acknowledged_at set
5. **test_query_alerts_by_symbol**: Create 3 alerts (2 SPY, 1 QQQ) → query SPY → returns 2
6. **test_query_alerts_by_status**: Create alerts → query ACTIVE → returns only active
7. **test_get_active_alerts**: Create alerts (mix of statuses) → get_active → returns only ACTIVE
8. **test_metadata_serialization**: Create alert with dict metadata → persists correctly
9. **test_delta_lake_persistence**: Create alert → write → read from Delta Lake → alert matches

**DecisionEngine integration (src/v6/decisions/engine.py):**
Add AlertManager integration to DecisionEngine:
```python
class DecisionEngine:
    def __init__(self, rules: list[Rule] | None = None, alert_manager: AlertManager | None = None):
        # ...
        self.alert_manager = alert_manager

    async def evaluate(self, snapshot, market_data=None) -> Decision:
        # ... existing rule evaluation logic ...

        # After decision made, create alert if not HOLD
        if self.alert_manager and decision.action != DecisionAction.HOLD:
            alert = await self.alert_manager.create_alert(decision, snapshot)

        return decision
```

Use pytest with async tests. Run with: `conda run -n ib pytest src/v6/alerts/test_manager.py -v`
  </action>
  <verify>
conda run -n ib pytest src/v6/alerts/test_manager.py -v shows all tests passing (9+ passed)
  </verify>
  <done>
All 9 tests pass, DecisionEngine integration works, alerts auto-created on decisions, Delta Lake persistence verified
  </done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `conda run -n ib pytest src/v6/alerts/test_manager.py -v` - all tests pass
- [ ] `python -c "from src.v6.alerts import AlertManager; print('Import success')"` - imports work
- [ ] AlertManager creates Delta Lake table on initialize()
- [ ] create_alert() maps Decision to Alert correctly (CLOSE → CRITICAL, ROLL → INFO, HOLD → skip)
- [ ] acknowledge/resolve/dismiss update status and timestamps
- [ ] query_alerts() filters by symbol, status, type, severity
- [ ] get_active_alerts() returns only ACTIVE status alerts
- [ ] DecisionEngine integration works (alerts auto-created)
</verification>

<success_criteria>

- Alert models created (Alert, AlertType, AlertSeverity, AlertStatus, AlertQuery)
- AlertManager with Delta Lake persistence
- Decision → Alert mapping correct (severity based on action + urgency)
- Alert lifecycle management (acknowledge, resolve, dismiss)
- Query functionality (by symbol, status, type, severity)
- DecisionEngine integration (auto-create alerts)
- All unit tests passing (9+ tests)
- No linting errors
  </success_criteria>

<output>
After completion, create `.planning/phases/3-decision-rules-engine/3-04-SUMMARY.md`:

# Phase 3 Plan 4: Alert Generation and Management Summary

**Implemented alert generation and management system with Delta Lake persistence.**

## Accomplishments

- Alert models and enums (AlertType, AlertSeverity, AlertStatus, Alert)
- AlertManager with Delta Lake persistence
- Decision → Alert mapping (severity based on action + urgency)
- Alert lifecycle management (acknowledge, resolve, dismiss)
- Query functionality (symbol, status, type, severity filters)
- DecisionEngine integration (auto-create alerts)
- Unit tests (9 tests, all passing)

## Files Created/Modified

- `src/v6/alerts/models.py` - Alert data models
- `src/v6/alerts/manager.py` - AlertManager with Delta Lake
- `src/v6/alerts/__init__.py` - Package exports
- `src/v6/alerts/test_manager.py` - Unit tests
- `src/v6/decisions/engine.py` - AlertManager integration

## Deviations from Plan

None - plan executed as specified.

## Phase 3 Complete

All 4 plans completed:
- ✅ 3-01: Rule evaluation framework
- ✅ 3-02: Portfolio-level risk calculations
- ✅ 3-03: 12 priority-based decision rules
- ✅ 3-04: Alert generation and management

**Phase 3: Decision Rules Engine COMPLETE**

Ready for Phase 4 (Strategy Execution).
</output>
