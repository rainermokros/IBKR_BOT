"""
Alert Data Models and Enums

This module provides data models for the alert management system.
Uses dataclasses with slots=True for performance (internal data, validated on entry).

Key patterns:
- dataclass(slots=True) for performance
- __post_init__ validation for data integrity
- Type hints for all fields
- Immutable where possible

Alert types:
- INFO: Normal operations (DTE roll reminder, position opened)
- WARNING: Risk warnings (delta approaching limit, gamma risk)
- CRITICAL: Immediate action required (catastrophe protection, stop loss)

Alert severity:
- IMMEDIATE: Act now (catastrophe, stop loss)
- HIGH: Act soon (take profit approaching)
- NORMAL: Monitor (DTE roll coming up)
- LOW: Informational (position stats)
"""

import json
import uuid
from dataclasses import dataclass, field
from datetime import datetime
from enum import Enum
from typing import Any, Optional


class AlertType(str, Enum):
    """
    Alert type enum.

    Categories of alerts for different situations.
    """

    INFO = "info"  # Normal operations
    WARNING = "warning"  # Risk warnings
    CRITICAL = "critical"  # Immediate action required


class AlertSeverity(str, Enum):
    """
    Alert severity enum.

    Indicates how urgently action should be taken.
    """

    IMMEDIATE = "immediate"  # Act now
    HIGH = "high"  # Act soon
    NORMAL = "normal"  # Monitor
    LOW = "low"  # Informational


class AlertStatus(str, Enum):
    """
    Alert status enum.

    Lifecycle states for an alert.
    """

    ACTIVE = "active"  # Alert is active
    ACKNOWLEDGED = "acknowledged"  # Alert has been acknowledged
    RESOLVED = "resolved"  # Alert has been resolved
    DISMISSED = "dismissed"  # Alert has been dismissed


@dataclass(slots=True)
class Alert:
    """
    Alert data model.

    Represents an alert generated by a decision rule.

    Attributes:
        alert_id: Unique alert identifier (UUID)
        type: Alert type (INFO, WARNING, CRITICAL)
        severity: Alert severity (IMMEDIATE, HIGH, NORMAL, LOW)
        status: Alert status (ACTIVE, ACKNOWLEDGED, RESOLVED, DISMISSED)
        title: Short summary of the alert
        message: Detailed description
        rule: Which rule triggered this alert
        symbol: Optional symbol this alert is for
        strategy_id: Optional strategy ID this alert is for
        metadata: Optional rule-specific data (JSON-serializable dict)
        created_at: When this alert was created
        acknowledged_at: When this alert was acknowledged (if applicable)
        resolved_at: When this alert was resolved/dismissed (if applicable)

    Raises:
        ValueError: If validation fails
    """

    alert_id: str
    type: AlertType
    severity: AlertSeverity
    status: AlertStatus
    title: str
    message: str
    rule: str
    symbol: Optional[str] = None
    strategy_id: Optional[int] = None
    metadata: dict[str, Any] = field(default_factory=dict)
    created_at: datetime = field(default_factory=datetime.now)
    acknowledged_at: Optional[datetime] = None
    resolved_at: Optional[datetime] = None

    def __post_init__(self):
        """
        Validate alert fields after initialization.

        Ensures data integrity before alert is used.
        """
        # Validate alert_id is not empty
        if not self.alert_id or not self.alert_id.strip():
            raise ValueError("Alert ID cannot be empty")

        # Validate title is not empty
        if not self.title or not self.title.strip():
            raise ValueError("Alert title cannot be empty")

        # Validate message is not empty
        if not self.message or not self.message.strip():
            raise ValueError("Alert message cannot be empty")

        # Validate rule is not empty
        if not self.rule or not self.rule.strip():
            raise ValueError("Alert rule cannot be empty")

        # Validate type is valid enum
        if not isinstance(self.type, AlertType):
            raise ValueError(f"Invalid alert type: {self.type}")

        # Validate severity is valid enum
        if not isinstance(self.severity, AlertSeverity):
            raise ValueError(f"Invalid alert severity: {self.severity}")

        # Validate status is valid enum
        if not isinstance(self.status, AlertStatus):
            raise ValueError(f"Invalid alert status: {self.status}")

        # Ensure metadata is a dict
        if not isinstance(self.metadata, dict):
            raise ValueError("Metadata must be a dictionary")

        # Validate timestamp consistency
        if self.status == AlertStatus.ACKNOWLEDGED and self.acknowledged_at is None:
            raise ValueError("Acknowledged alert must have acknowledged_at timestamp")

        if self.status in (AlertStatus.RESOLVED, AlertStatus.DISMISSED) and self.resolved_at is None:
            raise ValueError("Resolved/dismissed alert must have resolved_at timestamp")

    def to_dict(self) -> dict[str, Any]:
        """
        Convert alert to dictionary for Delta Lake storage.

        Returns:
            Dictionary with all alert fields, metadata serialized to JSON string
        """
        return {
            'alert_id': self.alert_id,
            'type': self.type.value,
            'severity': self.severity.value,
            'status': self.status.value,
            'title': self.title,
            'message': self.message,
            'rule': self.rule,
            'symbol': self.symbol,
            'strategy_id': self.strategy_id,
            'metadata': json.dumps(self.metadata) if self.metadata else None,
            'created_at': self.created_at,
            'acknowledged_at': self.acknowledged_at,
            'resolved_at': self.resolved_at,
        }

    @classmethod
    def from_dict(cls, data: dict[str, Any]) -> 'Alert':
        """
        Create alert from dictionary (Delta Lake row).

        Args:
            data: Dictionary with alert fields

        Returns:
            Alert instance
        """
        # Deserialize metadata from JSON
        metadata = {}
        if data.get('metadata'):
            try:
                metadata = json.loads(data['metadata'])
            except (json.JSONDecodeError, TypeError):
                metadata = {}

        return cls(
            alert_id=data['alert_id'],
            type=AlertType(data['type']),
            severity=AlertSeverity(data['severity']),
            status=AlertStatus(data['status']),
            title=data['title'],
            message=data['message'],
            rule=data['rule'],
            symbol=data.get('symbol'),
            strategy_id=data.get('strategy_id'),
            metadata=metadata,
            created_at=data['created_at'],
            acknowledged_at=data.get('acknowledged_at'),
            resolved_at=data.get('resolved_at'),
        )

    def __repr__(self) -> str:
        """Return string representation of alert."""
        return (
            f"Alert(id={self.alert_id[:8]}..., type={self.type.value}, "
            f"severity={self.severity.value}, status={self.status.value}, "
            f"title={self.title})"
        )


@dataclass(slots=True)
class AlertQuery:
    """
    Alert query data model.

    Used to query alerts from the AlertManager.

    Attributes:
        symbol: Optional filter by symbol
        strategy_id: Optional filter by strategy ID
        status: Optional filter by status
        type: Optional filter by alert type
        severity: Optional filter by severity
        start_time: Optional start of time range
        end_time: Optional end of time range
        limit: Maximum number of alerts to return (default: 100)
    """

    symbol: Optional[str] = None
    strategy_id: Optional[int] = None
    status: Optional[AlertStatus] = None
    type: Optional[AlertType] = None
    severity: Optional[AlertSeverity] = None
    start_time: Optional[datetime] = None
    end_time: Optional[datetime] = None
    limit: int = 100

    def __post_init__(self):
        """
        Validate alert query after initialization.

        Ensures data integrity before query is used.
        """
        # Validate limit is positive
        if self.limit <= 0:
            raise ValueError(f"Limit must be positive, got {self.limit}")

        # Validate limit is reasonable (max 1000)
        if self.limit > 1000:
            raise ValueError(f"Limit cannot exceed 1000, got {self.limit}")

        # Validate status is valid enum if provided
        if self.status is not None and not isinstance(self.status, AlertStatus):
            raise ValueError(f"Invalid alert status: {self.status}")

        # Validate type is valid enum if provided
        if self.type is not None and not isinstance(self.type, AlertType):
            raise ValueError(f"Invalid alert type: {self.type}")

        # Validate severity is valid enum if provided
        if self.severity is not None and not isinstance(self.severity, AlertSeverity):
            raise ValueError(f"Invalid alert severity: {self.severity}")

        # Validate time range
        if self.start_time and self.end_time:
            if self.start_time > self.end_time:
                raise ValueError("start_time must be before end_time")

    def __repr__(self) -> str:
        """Return string representation of query."""
        filters = []
        if self.symbol:
            filters.append(f"symbol={self.symbol}")
        if self.status:
            filters.append(f"status={self.status.value}")
        if self.type:
            filters.append(f"type={self.type.value}")
        if self.severity:
            filters.append(f"severity={self.severity.value}")

        filter_str = ", ".join(filters) if filters else "no filters"
        return f"AlertQuery({filter_str}, limit={self.limit})"


def generate_alert_id() -> str:
    """
    Generate a unique alert ID.

    Returns:
        UUID string (without dashes for compact storage)
    """
    return str(uuid.uuid4())
